# 1.0.3 고전적상속과 prototype상속의 차이점

[참고](http://www.nextree.co.kr/p7323/)

## 소스
* main1.js : 초창기 고전적 상속.
* main2.js : 특정 객체에 prototype만을 추가.

## Javascript에서 상속?

예전 2000년도의 Javascript는 마우스를 따라다니는 별, 버튼 클릭 했을때 alert창 보여주기 같은 간단한 수준의 이벤트를 처리하기 위해 사용했습니다.

웹의 개발 방법론에 따라 Javascript로만 웹페이지 동작 방식을 구현하기 시작하면서 점점 객체지향의 개념과 함께 상속이 활용되는것에 집중이 되면서 몇몇의 방법이 나오게 되었습니다.
 
초창기 상속 방식 및 prototype상속 방식에 관해서 정리를 하겠습니다.

고전적 상속과 prototypal한 상속의 차이점이란 고전적 상속은 new를 사용한 상속 방식이고 object객체나 Object.create()를 통한 상속을 prototypal한 상속 방식이라고 합니다.

둘의 차이점은 고전적 상속 방식보다 Object.create()를 사용한 상속 방식이 더 쉽다는 정도라고 할 수 있습니다.

결국 상속은 객체의 prototype체인을 통해서 구현합니다.

즉 내가 실행할때 실행되는 자식의 객체의 프로토타입에 부모로부터 상속할 데이터만 들어가면 되는 것입니다.

Object.create()의 역할은 파라메터를 프로퍼티로 갖는 새로운 객체를 리턴해주는 것입니다. Object.create(부모객체)를 하게 되면 부모 객체의 데이터를 property로 가진 빈객체를 넘겨주게 되는 거지요.

실제 이런경우 생성된 프로토타입의 Constructor는 몽땅 깨지게 됩니다. 또한 그렇기 때문에 더이상 instanceOf로 비교를 할수 가 없게 되지요.

ES6에서 Class 확장의 경우 모든 속성은 현재 생성된 필드에 삽입되고, 각각의 Constructor는 자신의 클래스의 전반적인 메소드들이 들어가게 됩니다. 또한 프로퍼티링크는 자신의 모든 메소드가 가르키게 되죠.

## ES6에서 상속
각 부모 자식간의 모든 클래스의 Constructor에 잇는 변수들을 생성된 객체에 순차적으로 반영합니다.

그리고 각각의현재 Constructor를 포함한 메소드들을 프로토타입에 반영합니다.

이게 다입니다.

 

